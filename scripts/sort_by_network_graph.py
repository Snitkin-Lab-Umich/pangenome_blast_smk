import os
import argparse
import pandas as pd
import networkx as nx

def sort_by_network_graph(input_file, graph_file, ctab_file, output_file):
    # take a networkx graph and a ctab table giving the order of gene families
    # use the ctab table to get the first gene family on each chromosome
    # use this information to sort the gene families in the input file
    pangraph = nx.read_gml(graph_path, label ='name')
    ctab_df = pd.read_csv(ctab_file, sep='\t', keep_default_na=False)
    compare_df = pd.read_csv(input_file, sep='\t', keep_default_na=False)
    # get the unique chromosomes from the ctab file, in order
    #### current plan
    # look at all of the network graph components with list(nx.connected_components(pangraph))
    # make a dictionary that converts gene name to its component index
    # subset the list of accessory genes by component index
    # within this subset, use nx.algorithms.simple_paths.all_simple_paths() to get the paths from the first gene on the chromosome to all other accessory genes
    # if a valid path is found, sort the subset df based on the resulting path
    # things to try:
    # make sure that row['Gene_Family'] is actually a string
    components = list(nx.connected_components(pangraph))
    gene_to_component = {}
    for i, comp in enumerate(components):
        for gene in comp:
            gene_to_component[gene] = i
    # assign each gene family to its component
    compare_df['Component'] = compare_df['Gene_Family'].map(gene_to_component)
    # iterate through each component and sort the gene families within it
    sorted_dfs = []
    for component_name, component_compare_df in compare_df.groupby('Component'):
        # get the first gene on the chromosome for this component, using the ctab file
        print(f'Processing component {component_name} with {len(component_compare_df)} gene families')
        start_gene = None
        for index, row in ctab_df.iterrows():
            if gene_to_component.get(row['Gene_Family']) == component_name:
                start_gene = row['Gene_Family']
                break
        print(f'First gene on chromosome for component {component_name}: {start_gene}')
        gene_list = component_compare_df['Gene_Family'].tolist()
        sub_pangraph = pangraph.subgraph([start_gene] + gene_list)
        paths = nx.single_source_shortest_path(sub_pangraph, start_gene)
        # create a mapping of gene to its distance from the start gene, if possible




def read_pangenome_graph(graph_path):
    pangraph = nx.read_gml(graph_path, label ='name')
    neighbor_dict = {}
    for node in pangraph.nodes:
        neighbors = list(pangraph.neighbors(node))
        neighbor_dict[node] = neighbors
    return neighbor_dict



def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--input','-i',type=str,
        help='''Provide a comparison file generated by the compare_panaroo_blast script.''',
        required=True
        )
    parser.add_argument(
        '--graph','-gml',type=str,
        help='''Provide a path to a pangenome graph file in GML format. Only needed for the neighbor_best_hit strategy.''',
        default=None
        )
    parser.add_argument(
        '--ctab','-c',type=str,
        help='''Provide a comparison table that has the order of gene families in B8441.''',
        required=True
        )
    parser.add_argument(
        '--output','-o',type=str,
        help='''Provide a path to an output file.''',
        default=None
        )
    args = parser.parse_args()
    sort_by_network_graph(args.input, args.graph, args.ctab, args.output)


if __name__ == '__main__':
    main()